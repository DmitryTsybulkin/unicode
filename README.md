## Unicode и кодировки UTF-8, UTF-16. Основная информация, необходимая для разработки ПО.
### История и введение

При разработке программы, где одной из главных составляющих является задача обработки текста (ввод, редактирование, чтение), важно понимание системы unicode. По своей природе, компьютеры на самом простом уровне работают с битами, но человеку необходимы более сложные сущности, такие как: числа, буквы и другие символы. Поэтому, для их представления в компьютерных системах используются специальные кодировки, способные преобразовывать числовые коды в символы. **Кодирование**, в свою очередь, – это представление какой-либо информации в ином, закодированном виде, не репрезентативном для человека, который можно вернуть в исходное состояние. **Кодировка** – это набор правил, описывающий способ перевода одного представления информации в другое. 

До появления стандарта unicode, в мире было множество разных схем кодирования символов. Однако, у них было значительное количество недостатков: не было универсальной кодировки — многие схемы были несовместимы по отношению друг к другу; они не описывали все необходимые пользователю символы (наличие множества языков). Для любого компьютера, особенно сервера, необходимо было поддерживать несколько кодировок, но даже при этом существовал риск того, что данные, при передаче, могли оказаться поврежденными.

Одна из наиболее популярных кодировок в тот момент это — ASCII. Всего в систему ASCII включены _128_ символов — она использует все комбинации семи битов (от _0000000_ до _1111111_). Например, последовательность бит двоичной системы _01000001_ в изложенной кодировке кодирует символ “A”, или _01000010_ кодирует символ “B”. Основная проблема ASCII заключалась в том, что эта кодировка неплохо работала только в англоязычной среде. Использовать её с другими языками было затруднительно.

С целью разрешить несистематизированность и попытаться унифицировать систему кодирования символов, которая могла бы использоваться для множества языков, в 1991 году некоммерческой организацией «Консорциум Юникода» был разработан и предложен стандарт Unicode. В этот консорциум входят такие лидеры компьютерной индустрии, как Apple, HP, IBM, Microsoft, Oracle и т.д. поэтому, эта схема кодирования используется почти во всех современных технологиях и стандартах, а консорциум ставит своими задачами — развитие и распространение этой системы. В результате использования этого стандарта, можно значительно сэкономить на поддержке программного обеспечения. Главной особенностью Unicode является то, что она присваивает уникальный код любому символу, независимо от платформы, программы или языка. 

Начиная с октября 1991 года, стандарт постоянно развивается. Последняя версия (12.1) вышла в мае 2019 года. В каждой новой версии появляется больше символов, иероглифов из восточных языков, эмодзи и различных письменностей.


### Устройство unicode

Стандарт состоит из двух основных частей: **универсального набора символов** (англ. Universal character set, UCS) и **семейства кодировок** (англ. Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Unicode символы и присваивает каждому символу код в виде неотрицательного целого числа, записываемого обычно в шестнадцатеричной форме с префиксом U+, например, U+040F. Семейство кодировок определяет способы преобразования кодов символов для передачи в потоке или в файле.

Общее количество кодовых позиций в unicode — _1 112 064_, несмотря на значительно больший объём возможных вариантов (_2^31 = 2 147 483 648_). Это было сделано для совместимости разных представлений: UTF-8, UTF-16 и UTF-32. В последней версии Unicode, за май 2019, количество всех символов составляет _137 994_.

Важно отметить, что стандарт unicode полностью совместим основным предшественником — ASCII. Есть конкретная область с кодами от _U+0000_ до _U+007F_, которая содержит символы набора ASCII, соответствующие их кодами в ASCII.

Простыми словами, Unicode – это просто огромная таблица соответствия символов и чисел, а различные UTF кодировки определяют, как эти числа переводятся в биты.


### Формы представления unicode: UTF-8 и UTF-16

Стандарт Unicode в настоящее время реализуется различными кодировками, самые распространённые — UTF-8 и UTF-16, кодировки с переменной длиной кодирования. 

То что кодировка переменной длины, значит, что один символ может быть закодирован разным количеством структурных единиц кодировки, то есть разным количеством байт. Если символ может быть закодирован одним байтом (потому что номер пункта символа очень маленький), UTF-8 закодирует его одним байтом. Если нужно 2 байта, то используется 2 байта. Так, например, латиница кодируется одним байтом, а кириллица двумя байтами. Кодировка сообщает старшим битам, сколькими битами кодируется текущий символ. Такой способ экономит место, но так же, тратит его в случае, если эти сигнальные биты часто используются. Пример кодирования:
```markdown
A UTF-8 _01000001_
A UTF-16 _00000000 01000001_
```
UTF-16 является компромиссом в использовании: все символы как минимум двухбайтные, но их размер может увеличиваться до 4 байт. На западных языках обычно эффективнее всего кодируются с использованием стандарта UTF-8 (так как большинство символов в таких текстах могут быть представлены в виде кодов размером в 1 байт). Если же говорить о восточных языках, то можно сказать, что файлы, хранящие тексты, написанные на этих языках, обычно получаются меньше при использовании UTF-16.

Любой символ юникода в кодировке UTF-16 может быть закодирован либо одной парой байт или кодовой парой, либо двумя.

Количество символов, кодируемых одной кодовой парой может быть _65 535 (2^16)_, что полностью совпадает с базовым блоком юникода. Все символы находящиеся в этом блоке в кодировке UTF-16 будут закодированы одной кодовой парой (двумя байтами), тут все просто.
```markdown
символ «o» (латиница) — _00000000 01101111_
символ «M» (кириллица) — _00000100 00011100_
```
Для символов, находящихся за пределами базового unicode диапазона потребуется уже две кодовые пары (4 байта). И механизм их кодирования немного сложнее.

Для пояснения, необходимо ввести понятие “суррогатной пары”. **Суррогатная пара** — это две кодовые пары используемые для кодирования одного символа (итого 4 байта). Для таких суррогатных пар в таблице юникода отведен специальный диапазон от D800 до DFFF. Это значит, что при преобразовании кодовой пары из байтового вида в шестнадцатеричный вы получаете число из этого диапазона, то перед вами не самостоятельный символ, а суррогатная пара.

Чтобы закодировать символ из диапазона _10000_ — _10FFFF_ (то есть символ для которого нужно использовать более одной кодовой пары) нужно:

1. Из кода символа вычесть _10000_ (шестнадцатеричное) (это наименьшее число из диапазона _10000_ — _10FFFF_)
2. В результате первого пункта будет получено число не больше _FFFFF_, занимающее до _20_ бит
3. Ведущие _10_ бит из полученного числа суммируются с _D800_ (начало диапазона суррогатных пар в юникоде)
4. Следующие _10_ бит суммируются с _DC00_ (тоже число из диапазона суррогатных пар)
5. После этого получатся 2 суррогатные пары по 16 бит, первые 6 бит в каждой такой паре отвечают за определение того что это суррогат,
6. Десятый бит в каждом суррогате отвечает за его порядок если это 1 то это первый суррогат, если 0, то второй.

(Подробнее в дополнительной литературе: _Как работают кодировки текста. Откуда появляются «кракозябры». Принципы кодирования. Обобщение и детальный разбор_).


### Нормализация unicode

Иногда, при обработке текста, можно встретить проблему того, что символы, выглядящие для человека одинаково, имеют различное внутреннее представление. Например, букву é в можно представить двумя способами:

1. С помощью одной кодовой точки _U+00E9_.
2. С помощью комбинации буквы e и знака акута, то есть — с помощью двух кодовых точек — _U+0065_ и _U+0301_ (комбинации символов).

Таким образом, визуально буква будет выглядеть идентично, но закодирована по-разному. Это может быть серьезной проблемой, при написании ПО, потому что она может возникнуть, например, при вводе пользователем каких либо данных: аутентификация в системе — пользователь ввёл верные данные для входа, однако, при поиске записей в БД, запись может быть не найдена, потому что коды символов различны. Для решения этой проблемы существуют алгоритмы **нормализации строк** (приведение их к каноническому виду).

Существуют четыре стандартных формы (алгоритма) нормализации:

- **NFC: Normalization Form Canonical Composition.** Форма нормализации C — алгоритм, согласно которому последовательно выполняются каноническая декомпозиция и каноническая композиция. 
- **NFD: Normalization Form Canonical Decomposition.** Каноническая декомпозиция — алгоритм, согласно которому выполняется рекурсивное разложение составных символов на последовательность из одного или нескольких простых символов в соответствии с таблицами декомпозиции. Рекурсивное потому, что в процессе разложения составной символ может быть разложен на несколько других, некоторые из которых тоже являются составными, и к которым применяется дальнейшее разложение.
- **NFKC: Normalization Form Compatibility Composition.** Форма нормализации KC — алгоритм, согласно которому последовательно выполняются совместимая декомпозиция (алгоритм NFKD) и каноническая композиция (алгоритм NFC).
- **NFKD: Normalization Form Compatibility Decomposition.** Форма нормализации KD — совместимая декомпозиция — алгоритм, согласно которому последовательно выполняются каноническая декомпозиция и замены символов текста по таблицам совместимой декомпозиции.

Чаще всего используется форма нормализации NFC. При использовании этого алгоритма все символы сначала подвергаются декомпозиции (процесс, при котором все буквы по возможности разбиваются на модификаторы), после чего все комбинирующиеся последовательности подвергаются повторной композиции (процесс, при котором все буквы по возможности объединяются в одну) в порядке, определяемом стандартом. Для практического применения можно выбрать любую форму. Главное — применять её последовательно. В результате поступление на вход программы одних и тех же данных всегда будет приводить к одному и тому же результату.

### Проблемы unicode

Несмотря на наличие такого унифицированного стандарта кодирования символов, у Unicode остаются некоторые нерешенные проблемы:
- Тексты на китайском, корейском и японском языках имеют традиционное написание сверху вниз, начиная с правого верхнего угла. Переключение горизонтального и вертикального написания для этих языков не предусмотрено в Unicode — это должно осуществляться средствами языков разметки или внутренними механизмами текстовых процессоров.
- Наличие или отсутствие в Unicode разных начертаний одного и того же символа в зависимости от языка. Нужно следить, чтобы текст всегда был правильно помечен как относящийся к тому или другому языку.
- Так, китайские иероглифы могут иметь разные начертания в китайском, японском (кандзи) и корейском (ханча), но при этом в Unicode обозначаются одним и тем же символом (так называемая CJK-унификация), хотя упрощённые и полные иероглифы всё же имеют разные коды.
- Аналогично, русский и сербский языки используют разное начертание курсивных букв п и т (в сербском они выглядят как и и ш, см. сербский курсив).
- Перевод из строчных букв в заглавные тоже зависит от языка.
- Даже с арабскими цифрами есть определённые типографские тонкости: цифры бывают «прописными» и «строчными», пропорциональными и моноширинными — для Unicode разницы между ними нет. Подобные нюансы остаются за программным обеспечением.

Некоторые недостатки связаны не с самим Unicode, а с возможностями обработчиков текста.

- Файлы нелатинского текста в Unicode всегда занимают больше места, так как один символ кодируется не одним байтом, как в различных национальных кодировках, а последовательностью байтов (исключение составляет UTF-8 для языков, алфавит которых укладывается в ASCII, а также наличие в тексте символов двух и более языков, алфавит которых не укладывается в ASCII). Файл шрифта, необходимый для отображения всех символов таблицы Unicode, занимает сравнительно много места в памяти и требует больших вычислительных ресурсов, чем шрифт только одного национального языка пользователя. С увеличением мощности компьютерных систем и удешевлением памяти и дискового пространства эта проблема становится всё менее существенной; тем не менее, она остаётся актуальной для портативных устройств, например, для мобильных телефонов.
- Хотя поддержка Unicode реализована в наиболее распространённых операционных системах, до сих пор не всё прикладное программное обеспечение поддерживает корректную работу с ним. В частности, не всегда обрабатываются метки порядка байтов (BOM) и плохо поддерживаются диакритические символы. Проблема является временной и есть следствие сравнительной новизны стандартов Unicode (в сравнении с однобайтовыми национальными кодировками).
- Производительность всех программ обработки строк (в том числе и сортировок в БД) снижается при использовании Unicode вместо однобайтовых кодировок.

### Безопасность unicode
Unicode — достаточно сложная система, в которой существует множество хитростей и лазеек: от невидимых символов и контрольных знаков до суррогатных пар и комбинированных эмодзи (когда при сложении двух знаков получается третий). По этой причине, злоумышленники, хорошо осведомленные о нюансах Unicode могут использовать их для атаки ПО.

Например, существует атака, описанная OWASP, направленная ​​на поиск недостатков в механизме декодирования, реализованном в приложениях при декодировании формата данных Unicode. Злоумышленник может использовать эту технику для кодирования определенных символов в URL-адресе, чтобы обойти фильтры приложений, таким образом получая доступ к ограниченным ресурсам на веб-сервере или принудительно просматривая защищенные страницы.

Другой пример уязвимости, найденной сравнительно недавно, это брешь в процедуре восстановления забытого пароля на GitHub, которая позволяла злоумышленнику получить пароль от чужого аккаунта.

В рамках этой процедуры восстановления, выполнялось сравнение введённого адреса электронной почты с адресом, который хранится в базе. Алгоритм проверки:

1) Введённый адрес переводится в нижний регистр с помощью метода `toLowerCase`.
2) Введённый адрес сравнивается с адресом в базе зарегистрированных пользователей.
3) Если найдено совпадение, пароль из базы данных высылается на введённый адрес.

Очевидно, разработчики не знали о коллизии трансляции адресов при использовании метода `toLowerCase`. В данном случае исправить ошибку просто. Достаточно отправить пароль не на введённый адрес, а на адрес из базы данных.

Связанные с Юникодом баги имеют такое свойство, что их можно встретить в любом приложении, которое обрабатывает текст, введённый пользователем. Уязвимости есть и в веб-приложениях, и в нативных программах под Android и iOS.

Большую известность получила [ошибка](https://threatpost.ru/apple-rushes-fix-for-latest-text-bomb-bug-as-abuse-spreads/24721/), связанная с воспроизведением символов Unicode для индийского языка телугу. Проблема возникала на некоторых версиях iOS в приложениях, использующих дефолтный шрифт San Francisсo. Получив всего несколько символов జ్ఞా, пользователь терял управление над многими приложениями в iOS, включая почту и Facebook. Если один из символов телугу появлялся во всплывающих уведомлениях, то блокировался SpringBoard — приложение, отвечающее за главный экран в iOS.

Ошибка изменения символов, приводящая к краху системы, [кроется в особенности](https://manishearth.github.io/blog/2018/02/15/picking-apart-the-crashing-ios-string/) языка телугу, бенгали и некоторых других диалектов. Она заключается в последовательном построении иероглифов из элементов письма — глифов, при этом имеется определенное расположение символов, не характерное для языка. К сбою приводит преобразование соединительных суффиксов в согласных: когда вторую согласную букву слоговой алфавитной письменности телугу присоединяют к первой согласной для объединения без значительного изменения формы слова. Вследствие несовместимости глифов возникает ошибка, которую не может обработать процессор устройства.

### Заключение
Подводя итог, можно отметить следующие важные моменты касательно Unicode:

1. Любому разработчику ПО, особенно веб- необходимо иметь базовое понимание устройства кодирования символов;
2. Выбор конкретной кодировки: UTF-8 или UTF-16, для разработки конкретного ПО, можно сделать на основе тех целей, которые нужно добиться. Для работы преимущественно с западными языками, хорошо подойдёт первый вариант, в случае поддержки восточных языков и множества других символов, подойдёт второй вариант. Если есть такая возможность, можно добавить поддержку нескольких кодировок, главное — помочь конечному пользователю с выбором требуемой;
3. При работе с кодировками, необходимо учитывать некоторые нюансы: комбинированные знаки, суррогатные пары и т.д. Важно использовать нормализацию строк и проводить различные виды тестирования, для поиска багов и уязвимостей.

### Источники и дополнительная литература
1. [Сайт стандарта unicode](https://www.unicode.org/standard/standard.html);
2. [Что нужно знать каждому разработчику о кодировках и наборах символов для работы с текстом 1](https://habr.com/ru/post/158639/);
3. [Что нужно знать каждому разработчику о кодировках и наборах символов для работы с текстом 2](https://habr.com/ru/post/158895/);
4. [Ссылка на описание в русскоязычной википедии](https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4);
5. [UTF-8 and Unicode FAQ for Unix/Linux](https://www.cl.cam.ac.uk/~mgk25/unicode.html);
6. [UTF-8 & UTF-16 FAQ](http://www.unicode.org/faq/utf_bom.html#UTF8);
7. [Как работают кодировки текста. Откуда появляются «кракозябры». Принципы кодирования. Обобщение и детальный разбор](https://habr.com/ru/post/478636/);
8. [Когда «Zoë» !== «Zoë», или почему нужно нормализовывать Unicode-строки](https://habr.com/ru/company/ruvds/blog/445274/);
9. [Нормализация Unicode](https://habr.com/ru/post/45489/)
10. [OWASP : attack by unicode encoding](https://www.owasp.org/index.php/Unicode_Encoding);
11. [Символьная уязвимость: как простое сообщение приводит к ошибкам в телефоне](https://habr.com/ru/company/yota/blog/354452/);
12. [Взлом с помощью Юникода (на примере GitHub)](https://habr.com/ru/company/globalsign/blog/481318/);
